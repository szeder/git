Git commit graph format
=======================

The Git commit graph stores a list of commit OIDs and some associated
metadata, including:

- The generation number of the commit. Commits with no parents have
  generation number 1; commits with parents have generation number
  one more than the maximum generation number of its parents. We
  reserve zero as special, and can be used to mark a generation
  number invalid or as "not computed".

- The root tree OID.

- The commit date.

- The parents of the commit, stored using positional references within
  the graph file.

These positional references are stored as unsigned 32-bit integers
corresponding to the array position within the list of commit OIDs. Due
to some special constants we use to track parents, we can store at most
(1 << 30) + (1 << 29) + (1 << 28) - 1 (around 1.8 billion) commits.

== Commit graph files have the following format:

In order to allow extensions that add extra data to the graph, we organize
the body into "chunks" and provide a binary lookup table at the beginning
of the body. The header includes certain values, such as number of chunks
and hash type.

All multi-byte numbers are in network byte order.

HEADER:

  4-byte signature:
      The signature is: {'C', 'G', 'P', 'H'}

  1-byte version number:
      Currently, the only valid version is 1.

  1-byte Hash Version (1 = SHA-1)
      We infer the hash length (H) from this value.

  1-byte number (C) of "chunks"

  1-byte number (B) of base commit-graphs
      We infer the length (H*B) of the Base Graphs chunk
      from this value.

CHUNK LOOKUP:

  (C + 1) * 12 bytes listing the table of contents for the chunks:
      First 4 bytes describe the chunk id. Value 0 is a terminating label.
      Other 8 bytes provide the byte-offset in current file for chunk to
      start. (Chunks are ordered contiguously in the file, so you can infer
      the length using the next chunk position if necessary.) Each chunk
      ID appears at most once.

  The remaining data in the body is described one chunk at a time, and
  these chunks may be given in any order. Chunks are required unless
  otherwise specified.

CHUNK DATA:

  OID Fanout (ID: {'O', 'I', 'D', 'F'}) (256 * 4 bytes)
      The ith entry, F[i], stores the number of OIDs with first
      byte at most i. Thus F[255] stores the total
      number of commits (N).

  OID Lookup (ID: {'O', 'I', 'D', 'L'}) (N * H bytes)
      The OIDs for all commits in the graph, sorted in ascending order.

  Commit Data (ID: {'C', 'D', 'A', 'T' }) (N * (H + 16) bytes)
    * The first H bytes are for the OID of the root tree.
    * The next 8 bytes are for the positions of the first two parents
      of the ith commit. Stores value 0x7000000 if no parent in that
      position. If there are more than two parents, the second value
      has its most-significant bit on and the other bits store an array
      position into the Extra Edge List chunk.
    * The next 8 bytes store the generation number of the commit and
      the commit time in seconds since EPOCH. The generation number
      uses the higher 30 bits of the first 4 bytes, while the commit
      time uses the 32 bits of the second 4 bytes, along with the lowest
      2 bits of the lowest byte, storing the 33rd and 34th bit of the
      commit time.

  Extra Edge List (ID: {'E', 'D', 'G', 'E'}) [Optional]
      This list of 4-byte values store the second through nth parents for
      all octopus merges. The second parent value in the commit data stores
      an array position within this list along with the most-significant bit
      on. Starting at that array position, iterate through this list of commit
      positions for the parents until reaching a value with the most-significant
      bit on. The other bits correspond to the position of the last parent.

  Base Graphs List (ID: {'B', 'A', 'S', 'E'}) [Optional]
      This list of H-byte hashes describe a set of B commit-graph files that
      form a commit-graph chain. The graph position for the ith commit in this
      file's OID Lookup chunk is equal to i plus the number of commits in all
      base graphs.  If B is non-zero, this chunk must exist.

  Modified Path Bloom Filter Index (ID: {'M', 'P', 'B', 'I'}) [Optional]
    2 + (N * 8) bytes

    * 1-byte number (K) of hashes per path

    * An array of 8 byte entries, one for each N commits stored in the
      commit-graph, with the ith entry associated to the ith commit in the
      OID Lookup chunk.
      Each entry should be interpreted as follows:

      - If all bits in the 8 bytes are set, then there is no modified path
	Bloom filter stored for this commit.

      - If the most significant bit of the first byte is set, then the
	remaining 63 bits represent the bit array of an "embedded" Bloom
	filter containing the set of paths that were modified between the
	associated commit and its first parent, or in case of a root commit
	between the associated commit and the empty tree.  All embedded
	modified path Bloom filters use the same hashing scheme that is
	used in the Modified Path Bloom Filters chunk, see below.

      - If the second most significant bit of the first byte is set, then
	the last four bytes form an array position into the Modified Path
	Bloom Filter Merge Index chunk.  The remaining bits in the first
	four bytes should be set to 0.  This can optionally be used to
	store Bloom filters for all parents of merge commits.
	[TODO: Only the last four bytes?  Shouldn't that be last 62 bits?!]

      - If the two most significant bits of the first byte are unset, then
	the entry represents an 8 byte offset pointing to a Bloom filter
	in the Modified Path Bloom Filters chunk, which contains the set
	of paths that were modified between the associated commit and its
	first parent, or in case of a root commit between the associated
	commit and the empty tree.  This offset is relative to the start
	of the Modified Path Bloom Filters chunk.  Multiple entries can
	point to the same offset.

  Modified Path Bloom Filter Merge Index (ID: {'M', 'P', 'B', 'M'}) [Optional]
      An array of 8 byte entries.
      If a merge commit's entry in the Modified Path Bloom Filter Index
      chunk stores an array position into this chunk, then the entry at
      that position is associated with that merge commit and its first
      parent, the next entry with that merge commit and its second parent,
      etc. for all parents of that merge commit.

      Each entry should be interpreted as follows, similar to the entries
      in the Modified Path Bloom Filter Index chunk:

      - If all bits in the 8 bytes are set, then there is no modified path
	Bloom filter stored for the associated merge commit and its
	corresponding parent.

      - If the MSB of the first byte is set, then the remaining 63 bits
	represent the bit array of an "embedded" Bloom filter containing
	the set of paths that were modified between the associated merge
	commit and its corresponding parent.  All embedded modified path
	Bloom filters use the same hashing scheme that is used in the
	Modified Path Bloom Filters chunk, see below.

      - If the most significant bit of the first byte is unset, then the
	entry represents an 8 byte offset pointing to a Bloom filter in
	the Modified Path Bloom Filters chunk, which contains the set of
	paths that were modified between the associated merge commit and
	its corresponding parent.  This offset is relative to the start of
	the Modified Path Bloom Filters chunk.  Multiple entries can point
	to the same offset.

      This chunk should not exist if the commit-graph file doesn't contain
      a Modified Path Bloom Filter Index chunk.  This chunk can be omitted
      if the Modified Path Bloom Filter Index doesn't contain any array
      indexes pointing into it.  This chunk can be omitted even when the
      commit-graph contains merge commits.

  Modified Path Bloom Filters (ID: {'M', 'P', 'B', 'F'}) [Optional]
      A number of consecuive modified path Bloom filters of varying sizes.
      Each Bloom filter consists of 4 + M bytes:

      - The first 4 bytes specify the number of m bits in the Bloom
	filter's bit array.

      - The next M bytes hold the Bloom filter's bit array of m bits.

      The bits in the array are indexed in network byte order, i.e. the
      array's 0th bit is the least significant bit of the last byte, and
      the (m-1)th bit is in the first byte.  If m is not a multiple of 8,
      then the unused leading bits should be set to 0.

      For each path (including leading directories) modified between a
      commit and its parent K bit positions should be set using the
      following hashing scheme:

	for i in [0, K)
	  bit_pos[i] = (hash1 + i * hash2 + (i * i * i - i) / 6) % m

      where hash1 and hash2 are the 32 bit MurmurHash3 hashes of the path
      with seeds 0xe83c5163 and 0x3b376b0c, respectively.  These bit
      positions should be calculated using 32 bit unsigned integer
      arithmetic.  The directory separator is a single '/'.  Directories
      should be added without a trailing '/'.

      The order of Bloom filters in this chunk is unspecified.  Multiple
      entries in the Modified Path Bloom Filter Index or Modified Path
      Bloom Filter Merge Index chunks can point to the same Bloom filter
      in this chunk.

      This chunk should not exist if the commit-graph doesn't contain a
      Modified Path Bloom Filter Index chunk.  This chunk can be omitted
      if neither the Modified Path Bloom Filter Index nor the Modified
      Path Bloom Filter Merge Index chunks contain any offsets pointing
      into it.

  Modified Path Bloom Filter Excludes (ID: {'M', 'P', 'B', 'X'}) [Optional]
      A number of consecutive null terminated strings in memcmp() order.
      Paths in these strings should not be added to any modified path
      Bloom filters.
      [TODO: Clarify!  Only literal matches, or should we support
      globbing/patterns as well?  Only full match, or leading directories
      as well?]

      This chunk should not exist if the commit-graph doesn't contain a
      Modified Path Bloom Filter Index chunk.

TRAILER:

	H-byte HASH-checksum of all of the above.
